#!/usr/bin/env bash

DEVICES=$(mpremote connect list | grep MicroPython | cut -d " " -f 1)

if [ -z $DEVICES ] ; then
  echo "No MicroPython devices found in FS mode"
  exit 1
fi

DEVICE=${DEVICES[0]}

# Needed trap to exit the script from the subshell when a function is used to
# set at variable like with: get_board_uid
trap "exit 1" SIGUSR1  # Trap ID = 10
proc="$$"

function echo_command_exit_code() {
  if [ $1 -eq 0 ]; then
    echo " .. done!"
  else
    echo " .. failed!"
  fi
}

function create_directory {
  echo -n "> creating directory $1"

  RESULT=$(mpremote connect ${DEVICE} mkdir $1)
  ERROR=$?


  if [ $ERROR -eq 0 ] ; then
    echo " .. done!"
  else
    if [[ "$RESULT" == *"EEXIST"* ]] ; then
      echo " .. already exists, skipping."
    else
      echo " .. failed!"
      echo "! it looks like this device is already in use - is Thonny running?"
      exit 1
    fi
  fi
}

function copy {
  for file in $1
  do
    echo -n "> copying file '$file' to: '$2'"
    mpremote connect ${DEVICE} cp $file $2 > /dev/null
    echo_command_exit_code $?
  done
}

# TODO Maybe do not edit the file but create a constants.py.curr and rename it on copy to the device
# OR the mpremote edit command can be used to edit the ref on the device
# OR the const file could be reverted after edit
# OR the version and rev are outsources in another file like system_consts.py
function update_git_rev() {
  file="${1:?"Need a file to update the rev as first argument"}"
  rev="${2:?"Need a git rev as second argument!"}"
  echo -n "> Updating Git REV in constants"
  # TODO Nasty hack to get it work on MacOS AND Linux'. Remove by utilising a Docker image ie. bash image if needed
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' -E "s/^(GIT_REV +=).*/\1 '$rev'/" "${file/:/}"
  else
    sed -i -E "s/^(GIT_REV +=).*/\1 '$rev'/" "${file/:/}"
  fi
  echo_command_exit_code $?
}

function get_board_uid() {
  RESULT=$(mpremote connect ${DEVICE} exec "import machine; print('{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}'.format(*machine.unique_id()), end='')")
  if [ $? -ne 0 ]; then
    echo "$RESULT" >&2
    kill -10 $proc
  fi
  echo "$RESULT"
}

function upload_actual_config() {
  board_uid="${1:?"Must provide a UID as first argument"}"
  act_config_file="configs/${board_uid}-config.py"
  echo "> Copying actual config ($act_config_file) for this board"
  if [ -f "$act_config_file" ]; then
    copy "$act_config_file" :config.py
  else
    echo " .. No config found for this board. Missing file: '$act_config_file'"
  fi
}

function download_file() {
  file="${1:?"Must specify a file to download from the remote filesystem!"}"
  out_dir="${2:-"./"}"
  out_file="$(date "+%Y-%m-%d_%H-%M-%S")-$(basename "${file/:/}")"
  echo -n "> download file '$file' to: '$out_dir' as '$out_file'"
  if [[ "." != "$out_dir" ]]; then
    mkdir -p "$out_dir"
    echo " .. No config found for this board. Missing file: '$act_config_file'"
  fi
}

function download_file() {
  file="${1:?"Must specify a file to download from the remote filesystem!"}"
  out_dir="${2:-"./"}"
  out_file="$(date "+%Y-%m-%d_%H-%M-%S")-$(basename "${file/:/}")"
  echo -n "> download file '$file' to: '$out_dir' as '$out_file'"
  if [[ "." != "$out_dir" ]]; then
    mkdir -p "$out_dir"
  fi

  # TODO Do check for a : on the file to decide if it is a directory and then
  # use the -r option in the bellow cp command!
  # In this case also skip the date part or better us it for the root folder
  # where the download goes to!
  result=$(mpremote connect ${DEVICE} cp "$file" "$out_dir/$out_file")
  error=$?
  if [[ "$result" == *"ENOENT"* ]]; then
    echo " .. does not exist (anymore)!"
    rmdir -p "$out_dir" 2> /dev/null
    return 0
  else
    echo_command_exit_code $error
  fi
}

function download_dir() {
  src_dir="${1:?"Must specify a directory to download from the remote filesystem!"}"
  out_dir="${2:-"./"}"
  echo "> download content of directory '$src_dir' to: '$out_dir'"
  if [[ "." != "$out_dir" ]]; then
    mkdir -p "$out_dir"
  fi

  files=$(mpremote connect ${DEVICE} ls "$src_dir" | awk '{print $2}' | sed -e '$d' | tr -d '\r')
  if [ $? -ne 0 ]; then
    echo "> failed to get content of dir: '$src_dir' for download. Aborting"
    return 0
  fi

  echo $files > test.out

  for fle in $files; do
    echo -n "  copy '$fle'"
    mpremote connect ${DEVICE} cp "$src_dir/$fle" "$out_dir/" > /dev/null
    echo_command_exit_code $?
  done

}

function clean_up() {
  echo "> Cleaning current content on device..."
  # Would be nice to provide the dirs dynamically. But mpremote run seems not to pass on
  # arguments to the script. Therefor the dirs to clean are hard coded in the python script!
  files="main.py log.txt config.py"
  for file in $files; do
    echo -n "> Removing '$file"
    mpremote connect ${DEVICE} rm ":$file" > /dev/null
    echo_command_exit_code $?
  done
  echo "> Cleaning directories..."
  mpremote connect ${DEVICE} run install_on_device_fs_helper.py
  echo_command_exit_code $?
}

# shellcheck disable=SC2120
function get_git_info() {
  long="${1:-false}"
  hash_short="$(git rev-parse --short HEAD 2> /dev/null | sed "s/\(.*\)/@\1/")"
  if [ "false" == "$long" ]; then
    echo -n "$hash_short"
  else
    dirty=""
    git diff --quiet --ignore-submodules HEAD 2>/dev/null
    if [ $? -eq 1 ]; then
      dirty="<Dirty>"
    fi
    branch="$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$dirty/")"
    echo -n "$branch$hash_short"
  fi

  # TODO Do check for a : on the file to decide if it is a directory and then
  # use the -r option in the bellow cp command!
  # In this case also skip the date part or better us it for the root folder
  # where the download goes to!
  result=$(mpremote connect ${DEVICE} cp "$file" "$out_dir/$out_file")
  error=$?
  if [[ "$result" == *"ENOENT"* ]]; then
    echo " .. does not exist (anymore)!"
    rmdir -p "$out_dir" 2> /dev/null
    return 0
  else
    echo_command_exit_code $error
  fi
}

function download_dir() {
  src_dir="${1:?"Must specify a directory to download from the remote filesystem!"}"
  out_dir="${2:-"./"}"
  echo "> download content of directory '$src_dir' to: '$out_dir'"
  if [[ "." != "$out_dir" ]]; then
    mkdir -p "$out_dir"
  fi

  files=$(mpremote connect ${DEVICE} ls "$src_dir" | awk '{print $2}' | sed -e '$d' | tr -d '\r')
  if [ $? -ne 0 ]; then
    echo "> failed to get content of dir: '$src_dir' for download. Aborting"
    return 0
  fi

  echo $files > test.out

  for fle in $files; do
    echo -n "  copy '$fle'"
    mpremote connect ${DEVICE} cp "$src_dir/$fle" "$out_dir/" > /dev/null
    echo_command_exit_code $?
  done

}

function clean_up() {
  echo "> Cleaning current content on device..."
  # Would be nice to provide the dirs dynamically. But mpremote run seems not to pass on
  # arguments to the script. Therefor the dirs to clean are hard coded in the python script!
  files="main.py log.txt config.py"
  for file in $files; do
    echo -n "> Removing '$file"
    mpremote connect ${DEVICE} rm ":$file" > /dev/null
    echo_command_exit_code $?
  done
  echo "> Cleaning directories..."
  mpremote connect ${DEVICE} run install_on_device_fs_helper.py
  echo_command_exit_code $?
}

# shellcheck disable=SC2120
function get_git_info() {
  long="${1:-false}"
  hash_short="$(git rev-parse --short HEAD 2> /dev/null | sed "s/\(.*\)/@\1/")"
  if [ "false" == "$long" ]; then
    echo -n "$hash_short"
  else
    dirty=""
    git diff --quiet --ignore-submodules HEAD 2>/dev/null
    if [ $? -eq 1 ]; then
      dirty="<Dirty>"
    fi
    branch="$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$dirty/")"
    echo -n "$branch$hash_short"
  fi
}

function get_uid() {
  mpremote connect ${DEVICE} exec "import machine; print('{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}'.format(*machine.unique_id()))"
}


current_board_uid="$(get_board_uid)"
current_git_rev="$(get_git_info)"


echo "> Working with device: '$DEVICE' with the UID: '$current_board_uid' on Git rev: '$current_git_rev'"


echo "> Downloading files...."

download_file ":log.txt" "./logs_dl/$current_board_uid"
download_file ":config.py" "./configs/$current_board_uid"
download_dir ":uploads" "./uploads/$current_board_uid"

echo "> Downloading files...."

download_file ":log.txt" "./logs_dl/$current_board_uid"
download_file ":config.py" "./configs/$current_board_uid"
download_dir ":uploads" "./uploads/$current_board_uid"

clean_up

update_git_rev enviro/constants.py $current_git_rev

echo "> Uploading Enviro firmware files..."

create_directory enviro
create_directory enviro/boards
create_directory enviro/destinations
create_directory enviro/html
create_directory enviro/html/images
create_directory phew
create_directory phew/phew

copy "main.py" :

update_git_rev :enviro/constants.py

copy "enviro/*.py" :enviro/

copy "enviro/boards/*.py" :enviro/boards/
copy "enviro/destinations/*.py" :enviro/destinations/

copy "enviro/html/*.html" :enviro/html/

copy "enviro/html/images/*" :enviro/html/images/

copy "phew/__init__.py" :phew/
copy "phew/phew/*.py" :phew/phew/

upload_actual_config $current_board_uid

# if [ -z "$(ls -A "uploads/$current_board_uid" 2> dev/null)" ]; then
if [ -z "$(find "uploads/$current_board_uid" -prune -empty  2> /dev/null)" ]; then
  create_directory uploads
  uploaded_postfix="uploaded"
  if copy "uploads/$current_board_uid/*.json" :uploads/; then
    echo -n "> removing old uploaded archive directory"
    rm -rf "uploads/$current_board_uid $uploaded_postfix" > /dev/null
    echo_command_exit_code $?
    echo -n "> renaming uploads directory"
    mv -f "uploads/$current_board_uid" "uploads/$current_board_uid $uploaded_postfix" > /dev/null
    # rm -rf "uploads/$current_board_uid/*.json" > /dev/null
    echo_command_exit_code $?
  else
    echo "> Failed to upload uploads! Keep them locally without renaming."
  fi
fi
